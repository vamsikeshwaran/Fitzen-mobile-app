/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { util } from '@tensorflow/tfjs-core';
const arrayProduct = (arr) => {
    let product = 1;
    for (let i = 0; i < arr.length; i++) {
        product *= arr[i];
    }
    return product;
};
export function tilesFitEvenlyIntoShape(tileSize, shape) {
    if (tileSize.length !== shape.length) {
        throw new Error(`Cannot compute whether rank ${tileSize.length}` +
            ` tiles fit evenly into rank ${shape.length} shape` +
            ` - ranks must match.`);
    }
    return shape.every((dim, dimIdx) => dim % tileSize[dimIdx] === 0);
}
// Computes dispatch geometry based on layout of output dimensions and
// workgroupSize.
export function computeDispatch(layout, outputShape, workgroupSize = [1, 1, 1], elementsPerThread = [1, 1, 1]) {
    const [dispatchX, dispatchY, dispatchZ] = [
        Math.ceil(arrayProduct(layout.x.map(d => outputShape[d])) /
            (workgroupSize[0] * elementsPerThread[0])),
        layout.y ? Math.ceil(arrayProduct(layout.y.map(d => outputShape[d])) /
            (workgroupSize[1] * elementsPerThread[1])) :
            1,
        layout.z ? Math.ceil(arrayProduct(layout.z.map(d => outputShape[d])) /
            (workgroupSize[2] * elementsPerThread[2])) :
            1
    ];
    return [dispatchX, dispatchY, dispatchZ];
}
export function computeWorkgroupInfoForMatMul(dimAOuter, dimInner, dimBOuter, transposeA = false) {
    // These are experimental values. Usually, we need to adjust the work group
    // size based on the input shapes to improve the EU occupancy.
    // TODO: WebGPU limits the maximum allowed shared memory size as 16K. To make
    // sure it doesn't exceed this limitations. Temporarily reduce the work group
    // size to [8, 8, 1] and the work per thread size is [4, 4, 1]. But we should
    // revisit it and find the balance between work group size and work per thread
    // size.
    const workgroupSize = [8, 8, 1];
    const elementsPerThread = [4, 4, 1];
    if (!transposeA) {
        if (dimAOuter <= 8) {
            elementsPerThread[1] = 1;
        }
        if (dimInner <= 16 && dimBOuter <= 16) {
            workgroupSize[0] = 4;
        }
    }
    return { workgroupSize, elementsPerThread };
}
export function computeWorkgroupSizeForConv2d(layout, outputShape, isVec4 = false) {
    if (isVec4) {
        return [8, 8, 1];
    }
    const dim0 = arrayProduct(layout.x.map(d => outputShape[d]));
    const dim1 = arrayProduct(layout.y.map(d => outputShape[d]));
    // TODO(jiajia.qin@intel.com): More fine tune based on outputShape.
    // These are experimental values. Usually, we need to adjust the work group
    // size based on the output shape. For example, when one dimension is smaller
    // than 4, it will be wasteful if we assign a larger size for this dimension,
    // which results lots of threads doing useless work and reduces parallelism
    // of hardware threads. But it is always a balance between work group size
    // and shared memory. If one dimension is too small, such as 1, shared memory
    // will won't be fully utilized.
    if (dim0 <= 4) {
        return [4, 16, 1];
    }
    if (dim1 <= 4) {
        return [16, 4, 1];
    }
    return [16, 16, 1];
}
export function computeWorkPerThreadForConv2d(layout, outputShape, isVec4 = false) {
    if (isVec4) {
        return [4, 4, 1];
    }
    const dim0 = arrayProduct(layout.x.map(d => outputShape[d]));
    const dim1 = arrayProduct(layout.y.map(d => outputShape[d]));
    // TODO(jiajia.qin@intel.com): More fine tune based on outputShape.
    // The following conditions correspond to the values set in
    // computeWorkgroupSizeForConv2d.
    if (dim0 <= 4) {
        return [1, 2, 1];
    }
    if (dim1 <= 4) {
        return [2, 1, 1];
    }
    return [2, 2, 1];
}
export function flatDispatchLayout(shape) {
    return { x: shape.map((d, i) => i) };
}
export function GPUBytesPerElement(dtype) {
    if (dtype === 'float32' || dtype === 'int32' || dtype === 'bool' ||
        dtype === 'string') {
        return 4;
    }
    else if (dtype === 'complex64') {
        return 8;
    }
    else {
        throw new Error(`Unknown dtype ${dtype}`);
    }
}
export function isWebGPUSupported() {
    return !!(typeof globalThis !== 'undefined' && (globalThis.navigator)
        && (globalThis.navigator.gpu));
}
export function assertNotComplex(tensor, opName) {
    if (!Array.isArray(tensor)) {
        tensor = [tensor];
    }
    tensor.forEach(t => {
        if (t != null) {
            util.assert(t.dtype !== 'complex64', () => `${opName} does not support complex64 tensors ` +
                'in the WebGPU backend.');
        }
    });
}
export var MatMulProgramType;
(function (MatMulProgramType) {
    MatMulProgramType[MatMulProgramType["MatMulReduceProgram"] = 0] = "MatMulReduceProgram";
    MatMulProgramType[MatMulProgramType["MatMulSplitKProgram"] = 1] = "MatMulSplitKProgram";
    MatMulProgramType[MatMulProgramType["MatMulSmallOutputSizeProgram"] = 2] = "MatMulSmallOutputSizeProgram";
    MatMulProgramType[MatMulProgramType["MatMulPackedProgram"] = 3] = "MatMulPackedProgram";
    MatMulProgramType[MatMulProgramType["MatMulMax"] = 4] = "MatMulMax";
})(MatMulProgramType || (MatMulProgramType = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2ViZ3B1X3V0aWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy93ZWJncHVfdXRpbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFDSCxPQUFPLEVBQXVCLElBQUksRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRWpFLE1BQU0sWUFBWSxHQUFHLENBQUMsR0FBYSxFQUFFLEVBQUU7SUFDckMsSUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDO0lBQ2hCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ25DLE9BQU8sSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDbkI7SUFDRCxPQUFPLE9BQU8sQ0FBQztBQUNqQixDQUFDLENBQUM7QUFFRixNQUFNLFVBQVUsdUJBQXVCLENBQ25DLFFBQWtCLEVBQUUsS0FBZTtJQUNyQyxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssS0FBSyxDQUFDLE1BQU0sRUFBRTtRQUNwQyxNQUFNLElBQUksS0FBSyxDQUNYLCtCQUErQixRQUFRLENBQUMsTUFBTSxFQUFFO1lBQ2hELCtCQUErQixLQUFLLENBQUMsTUFBTSxRQUFRO1lBQ25ELHNCQUFzQixDQUFDLENBQUM7S0FDN0I7SUFDRCxPQUFPLEtBQUssQ0FBQyxLQUFLLENBQ2QsQ0FBQyxHQUFXLEVBQUUsTUFBYyxFQUFFLEVBQUUsQ0FBQyxHQUFHLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0FBQ3JFLENBQUM7QUFFRCxzRUFBc0U7QUFDdEUsaUJBQWlCO0FBQ2pCLE1BQU0sVUFBVSxlQUFlLENBQzNCLE1BQWlELEVBQUUsV0FBcUIsRUFDeEUsZ0JBQTBDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMs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QU0sc0NBQXNDO2dCQUNqRCx3QkFBd0IsQ0FBQyxDQUFDO1NBQ25DO0lBQ0gsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBRUQsTUFBTSxDQUFOLElBQVksaUJBTVg7QUFORCxXQUFZLGlCQUFpQjtJQUMzQix1RkFBbUIsQ0FBQTtJQUNuQix1RkFBbUIsQ0FBQTtJQUNuQix5R0FBNEIsQ0FBQTtJQUM1Qix1RkFBbUIsQ0FBQTtJQUNuQixtRUFBUyxDQUFBO0FBQ1gsQ0FBQyxFQU5XLGlCQUFpQixLQUFqQixpQkFBaUIsUUFNNUIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5pbXBvcnQge0RhdGFUeXBlLCBUZW5zb3JJbmZvLCB1dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG5jb25zdCBhcnJheVByb2R1Y3QgPSAoYXJyOiBudW1iZXJbXSkgPT4ge1xuICBsZXQgcHJvZHVjdCA9IDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJvZHVjdCAqPSBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHByb2R1Y3Q7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdGlsZXNGaXRFdmVubHlJbnRvU2hhcGUoXG4gICAgdGlsZVNpemU6IG51bWJlcltdLCBzaGFwZTogbnVtYmVyW10pOiBib29sZWFuIHtcbiAgaWYgKHRpbGVTaXplLmxlbmd0aCAhPT0gc2hhcGUubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGNvbXB1dGUgd2hldGhlciByYW5rICR7dGlsZVNpemUubGVuZ3RofWAgK1xuICAgICAgICBgIHRpbGVzIGZpdCBldmVubHkgaW50byByYW5rICR7c2hhcGUubGVuZ3RofSBzaGFwZWAgK1xuICAgICAgICBgIC0gcmFua3MgbXVzdCBtYXRjaC5gKTtcbiAgfVxuICByZXR1cm4gc2hhcGUuZXZlcnkoXG4gICAgICAoZGltOiBudW1iZXIsIGRpbUlkeDogbnVtYmVyKSA9PiBkaW0gJSB0aWxlU2l6ZVtkaW1JZHhdID09PSAwKTtcbn1cblxuLy8gQ29tcHV0ZXMgZGlzcGF0Y2ggZ2VvbWV0cnkgYmFzZWQgb24gbGF5b3V0IG9mIG91dHB1dCBkaW1lbnNpb25zIGFuZFxuLy8gd29ya2dyb3VwU2l6ZS5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlRGlzcGF0Y2goXG4gICAgbGF5b3V0OiB7eDogbnVtYmVyW10sIHk/OiBudW1iZXJbXSwgej86IG51bWJlcltdfSwgb3V0cHV0U2hhcGU6IG51bWJlcltdLFxuICAgIHdvcmtncm91cFNpemU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFsxLCAxLCAxXSxcbiAgICBlbGVtZW50c1BlclRocmVhZDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdID1cbiAgICAgICAgWzEsIDEsIDFdKTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdIHtcbiAgY29uc3QgW2Rpc3BhdGNoWCwgZGlzcGF0Y2hZLCBkaXNwYXRjaFpdID0gW1xuICAgIE1hdGguY2VpbChcbiAgICAgICAgYXJyYXlQcm9kdWN0KGxheW91dC54Lm1hcChkID0+IG91dHB1dFNoYXBlW2RdKSkgL1xuICAgICAgICAod29ya2dyb3VwU2l6ZVswXSAqIGVsZW1lbnRzUGVyVGhyZWFkWzBdKSksXG4gICAgbGF5b3V0LnkgPyBNYXRoLmNlaWwoXG4gICAgICAgICAgICAgICAgICAgYXJyYXlQcm9kdWN0KGxheW91dC55Lm1hcChkID0+IG91dHB1dFNoYXBlW2RdKSkgL1xuICAgICAgICAgICAgICAgICAgICh3b3JrZ3JvdXBTaXplWzFdICogZWxlbWVudHNQZXJUaHJlYWRbMV0pKSA6XG4gICAgICAgICAgICAgICAxLFxuICAgIGxheW91dC56ID8gTWF0aC5jZWlsKFxuICAgICAgICAgICAgICAgICAgIGFycmF5UHJvZHVjdChsYXlvdXQuei5tYXAoZCA9PiBvdXRwdXRTaGFwZVtkXSkpIC9cbiAgICAgICAgICAgICAgICAgICAod29ya2dyb3VwU2l6ZVsyXSAqIGVsZW1lbnRzUGVyVGhyZWFkWzJdKSkgOlxuICAgICAgICAgICAgICAgMVxuICBdO1xuICByZXR1cm4gW2Rpc3BhdGNoWCwgZGlzcGF0Y2hZLCBkaXNwYXRjaFpdO1xufVxuXG5leHBvcnQgdHlwZSBXb3JrZ3JvdXBJbmZvID0ge1xuICB3b3JrZ3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gIGVsZW1lbnRzUGVyVGhyZWFkOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVdvcmtncm91cEluZm9Gb3JNYXRNdWwoXG4gICAgZGltQU91dGVyOiBudW1iZXIsIGRpbUlubmVyOiBudW1iZXIsIGRpbUJPdXRlcjogbnVtYmVyLFxuICAgIHRyYW5zcG9zZUEgPSBmYWxzZSk6IFdvcmtncm91cEluZm8ge1xuICAvLyBUaGVzZSBhcmUgZXhwZXJpbWVudGFsIHZhbHVlcy4gVXN1YWxseSwgd2UgbmVlZCB0byBhZGp1c3QgdGhlIHdvcmsgZ3JvdXBcbiAgLy8gc2l6ZSBiYXNlZCBvbiB0aGUgaW5wdXQgc2hhcGVzIHRvIGltcHJvdmUgdGhlIEVVIG9jY3VwYW5jeS5cbiAgLy8gVE9ETzogV2ViR1BVIGxpbWl0cyB0aGUgbWF4aW11bSBhbGxvd2VkIHNoYXJlZCBtZW1vcnkgc2l6ZSBhcyAxNksuIFRvIG1ha2VcbiAgLy8gc3VyZSBpdCBkb2Vzbid0IGV4Y2VlZCB0aGlzIGxpbWl0YXRpb25zLiBUZW1wb3JhcmlseSByZWR1Y2UgdGhlIHdvcmsgZ3JvdXBcbiAgLy8gc2l6ZSB0byBbOCwgOCwgMV0gYW5kIHRoZSB3b3JrIHBlciB0aHJlYWQgc2l6ZSBpcyBbNCwgNCwgMV0uIEJ1dCB3ZSBzaG91bGRcbiAgLy8gcmV2aXNpdCBpdCBhbmQgZmluZCB0aGUgYmFsYW5jZSBiZXR3ZWVuIHdvcmsgZ3JvdXAgc2l6ZSBhbmQgd29yayBwZXIgdGhyZWFkXG4gIC8vIHNpemUuXG4gIGNvbnN0IHdvcmtncm91cFNpemU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFs4LCA4LCAxXTtcbiAgY29uc3QgZWxlbWVudHNQZXJUaHJlYWQ6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFs0LCA0LCAxXTtcblxuICBpZiAoIXRyYW5zcG9zZUEpIHtcbiAgICBpZiAoZGltQU91dGVyIDw9IDgpIHtcbiAgICAgIGVsZW1lbnRzUGVyVGhyZWFkWzFdID0gMTtcbiAgICB9XG5cbiAgICBpZiAoZGltSW5uZXIgPD0gMTYgJiYgZGltQk91dGVyIDw9IDE2KSB7XG4gICAgICB3b3JrZ3JvdXBTaXplWzBdID0gNDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge3dvcmtncm91cFNpemUsIGVsZW1lbnRzUGVyVGhyZWFkfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVXb3JrZ3JvdXBTaXplRm9yQ29udjJkKFxuICAgIGxheW91dDoge3g6IG51bWJlcltdLCB5PzogbnVtYmVyW10sIHo/OiBudW1iZXJbXX0sIG91dHB1dFNoYXBlOiBudW1iZXJbXSxcbiAgICBpc1ZlYzQgPSBmYWxzZSk6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSB7XG4gIGlmIChpc1ZlYzQpIHtcbiAgICByZXR1cm4gWzgsIDgsIDFdO1xuICB9XG5cbiAgY29uc3QgZGltMCA9IGFycmF5UHJvZHVjdChsYXlvdXQueC5tYXAoZCA9PiBvdXRwdXRTaGFwZVtkXSkpO1xuICBjb25zdCBkaW0xID0gYXJyYXlQcm9kdWN0KGxheW91dC55Lm1hcChkID0+IG91dHB1dFNoYXBlW2RdKSk7XG4gIC8vIFRPRE8oamlhamlhLnFpbkBpbnRlbC5jb20pOiBNb3JlIGZpbmUgdHVuZSBiYXNlZCBvbiBvdXRwdXRTaGFwZS5cbiAgLy8gVGhlc2UgYXJlIGV4cGVyaW1lbnRhbCB2YWx1ZXMuIFVzdWFsbHksIHdlIG5lZWQgdG8gYWRqdXN0IHRoZSB3b3JrIGdyb3VwXG4gIC8vIHNpemUgYmFzZWQgb24gdGhlIG91dHB1dCBzaGFwZS4gRm9yIGV4YW1wbGUsIHdoZW4gb25lIGRpbWVuc2lvbiBpcyBzbWFsbGVyXG4gIC8vIHRoYW4gNCwgaXQgd2lsbCBiZSB3YXN0ZWZ1bCBpZiB3ZSBhc3NpZ24gYSBsYXJnZXIgc2l6ZSBmb3IgdGhpcyBkaW1lbnNpb24sXG4gIC8vIHdoaWNoIHJlc3VsdHMgbG90cyBvZiB0aHJlYWRzIGRvaW5nIHVzZWxlc3Mgd29yayBhbmQgcmVkdWNlcyBwYXJhbGxlbGlzbVxuICAvLyBvZiBoYXJkd2FyZSB0aHJlYWRzLiBCdXQgaXQgaXMgYWx3YXlzIGEgYmFsYW5jZSBiZXR3ZWVuIHdvcmsgZ3JvdXAgc2l6ZVxuICAvLyBhbmQgc2hhcmVkIG1lbW9yeS4gSWYgb25lIGRpbWVuc2lvbiBpcyB0b28gc21hbGwsIHN1Y2ggYXMgMSwgc2hhcmVkIG1lbW9yeVxuICAvLyB3aWxsIHdvbid0IGJlIGZ1bGx5IHV0aWxpemVkLlxuICBpZiAoZGltMCA8PSA0KSB7XG4gICAgcmV0dXJuIFs0LCAxNiwgMV07XG4gIH1cbiAgaWYgKGRpbTEgPD0gNCkge1xuICAgIHJldHVybiBbMTYsIDQsIDFdO1xuICB9XG5cbiAgcmV0dXJuIFsxNiwgMTYsIDFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVdvcmtQZXJUaHJlYWRGb3JDb252MmQoXG4gICAgbGF5b3V0OiB7eDogbnVtYmVyW10sIHk/OiBudW1iZXJbXSwgej86IG51bWJlcltdfSwgb3V0cHV0U2hhcGU6IG51bWJlcltdLFxuICAgIGlzVmVjNCA9IGZhbHNlKTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdIHtcbiAgaWYgKGlzVmVjNCkge1xuICAgIHJldHVybiBbNCwgNCwgMV07XG4gIH1cblxuICBjb25zdCBkaW0wID0gYXJyYXlQcm9kdWN0KGxheW91dC54Lm1hcChkID0+IG91dHB1dFNoYXBlW2RdKSk7XG4gIGNvbnN0IGRpbTEgPSBhcnJheVByb2R1Y3QobGF5b3V0LnkubWFwKGQgPT4gb3V0cHV0U2hhcGVbZF0pKTtcbiAgLy8gVE9ETyhqaWFqaWEucWluQGludGVsLmNvbSk6IE1vcmUgZmluZSB0dW5lIGJhc2VkIG9uIG91dHB1dFNoYXBlLlxuICAvLyBUaGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgY29ycmVzcG9uZCB0byB0aGUgdmFsdWVzIHNldCBpblxuICAvLyBjb21wdXRlV29ya2dyb3VwU2l6ZUZvckNvbnYyZC5cbiAgaWYgKGRpbTAgPD0gNCkge1xuICAgIHJldHVybiBbMSwgMiwgMV07XG4gIH1cbiAgaWYgKGRpbTEgPD0gNCkge1xuICAgIHJldHVybiBbMiwgMSwgMV07XG4gIH1cblxuICByZXR1cm4gWzIsIDIsIDFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmxhdERpc3BhdGNoTGF5b3V0KHNoYXBlOiBudW1iZXJbXSkge1xuICByZXR1cm4ge3g6IHNoYXBlLm1hcCgoZCwgaSkgPT4gaSl9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gR1BVQnl0ZXNQZXJFbGVtZW50KGR0eXBlOiBEYXRhVHlwZSk6IG51bWJlciB7XG4gIGlmIChkdHlwZSA9PT0gJ2Zsb2F0MzInIHx8IGR0eXBlID09PSAnaW50MzInIHx8IGR0eXBlID09PSAnYm9vbCcgfHxcbiAgICAgIGR0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiA0O1xuICB9IGVsc2UgaWYgKGR0eXBlID09PSAnY29tcGxleDY0Jykge1xuICAgIHJldHVybiA4O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkdHlwZSAke2R0eXBlfWApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1dlYkdQVVN1cHBvcnRlZCgpOiBib29sZWFuIHtcbiAgcmV0dXJuICEhKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiAoZ2xvYmFsVGhpcy5uYXZpZ2F0b3IpXG4gICAgJiYgKGdsb2JhbFRoaXMubmF2aWdhdG9yLmdwdSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0Tm90Q29tcGxleChcbiAgICB0ZW5zb3I6IFRlbnNvckluZm98VGVuc29ySW5mb1tdLCBvcE5hbWU6IHN0cmluZyk6IHZvaWQge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodGVuc29yKSkge1xuICAgIHRlbnNvciA9IFt0ZW5zb3JdO1xuICB9XG4gIHRlbnNvci5mb3JFYWNoKHQgPT4ge1xuICAgIGlmICh0ICE9IG51bGwpIHtcbiAgICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICAgIHQuZHR5cGUgIT09ICdjb21wbGV4NjQnLFxuICAgICAgICAgICgpID0+IGAke29wTmFtZX0gZG9lcyBub3Qgc3VwcG9ydCBjb21wbGV4NjQgdGVuc29ycyBgICtcbiAgICAgICAgICAgICAgJ2luIHRoZSBXZWJHUFUgYmFja2VuZC4nKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZW51bSBNYXRNdWxQcm9ncmFtVHlwZSB7XG4gIE1hdE11bFJlZHVjZVByb2dyYW0sXG4gIE1hdE11bFNwbGl0S1Byb2dyYW0sXG4gIE1hdE11bFNtYWxsT3V0cHV0U2l6ZVByb2dyYW0sXG4gIE1hdE11bFBhY2tlZFByb2dyYW0sXG4gIE1hdE11bE1heFxufVxuIl19